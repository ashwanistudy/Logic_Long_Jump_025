<!DOCTYPE html>
<html lang="en">


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search</title> 
    <link rel="stylesheet" href="./Algo_CSS/BinarySearch.css">
</head>
<body>
    <header>
        <nav></nav>
    </header>

    <main>
        <div class="container">
            <!-- Abhishek -->
            <section id="s1">
                <h1 id="s1_topic">Binary Search</h1><a href="./Two_Pointer.html">2pointer</a>
                <form action="#" class="form">
                    <input type="text" name="user-input" id="s1_input1" placeholder="Enter an Array (comma Separated)"
                        required>
                    <input type="number" name="user-input" id="s1_input2" placeholder="Target value" required>

                    <input type="submit" value="Find Target" class="s1_submit">
                    <button id="reset">Reset</button>

                </form>
            </section><!-- section1 -->

            <section id="s2"><!-- section2 -->
                <div id="visualizer">

                    <ul id="list">
                    </ul>
                </div>
                <div>
                    <h2 id="text"></h2>
                  </div>
</section>
                <section id="s3"><!-- section3 -->
                    <div id="description">
                        <h2>overview</h2>
                        <p id="p1">Binary Search is a fundamental algorithm in computer science used for finding an
                            element in a sorted array. It follows the principle of dividing the search interval in half
                            repeatedly until the target value is found or the interval is empty. Binary Search is known
                            for its efficiency and speed, making it a widely used algorithm in various applications.</p>

                        <h2>What is Binary Search?</h2>
                        <p id="p1">Binary Search is an efficient algorithm for finding an item from a sorted list of
                            items. It works by repeatedly dividing the search interval in half. If the value of the
                            target element is less than the middle element of the interval, the interval is narrowed to
                            the lower half. Otherwise, it is narrowed to the upper half. The process continues until the
                            target element is found or the interval is empty.</p>

                        <div id="iframe_div">
                            <iframe width="560" height="315"
                                src="https://www.youtube.com/embed/MHf6awe89xw?si=G0w6OzuupRRELy9V"
                                title="YouTube video player" frameborder="0"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                        </div>

                        <h2>Steps of Binary Search Algorithm</h2>
                        <h3>Step 1:<p>Start with the middle element of the sorted array. </p>
                        </h3>
                        <h3>Step 2:<p>If the middle element is the target value, return its index. Step</p>
                        </h3>
                        <h3>Step 3:<p>If the target value is less than the middle element, repeat the search on the left
                                half. </p>
                        </h3>
                        <h3>Step 4:<p>If the target value is greater than the middle element, repeat the search on the
                                right half. </p>
                        </h3>
                        <h3>Step 5:<p>Continue until the target value is found or the search interval is empty.</h3>



                        <h2>Properties of Binary Search</h2>
                        <h3>Efficiency:<p>Operates in O(log n) time complexity, making it highly efficient for large
                                datasets.</p>
                        </h3>

                        <h3>Requires Sorted Data: <p>Can only be applied to a sorted array or list. </p>
                        </h3>

                        <h3>Divide and Conquer:<p>Utilizes the divide and conquer strategy by repeatedly dividing the
                                search interval.</p>
                        </h3>


                        <h2>Applications of Binary Search</h2>
                        <h3>Searching in Databases:<p>Used to quickly find records in large databases. </p>
                        </h3>

                        <h3> Dictionary Lookups:<p>Efficiently looks up words and their meanings in a dictionary. </p>
                        </h3>

                        <h3>Debugging:<p>Helps in debugging by quickly narrowing down the location of errors in code.
                            </p>
                        </h3>

                        <h3>Data Analysis:<p>Used in various data analysis techniques to efficiently search through
                                data.
                            </p>
                        </h3>

                        <h3>Games:<p>Used in games for various search-related functionalities, such as pathfinding.</p>
                        </h3>


                        <h2>Advantages of Using Binary Search</h2>
                        <h3>High Efficiency:<p>Much faster than linear search for large datasets due to its O(log n)
                                time complexity.</p>
                        </h3>

                        <h3>Simplicity:<p>Relatively simple algorithm to understand and implement.</p>
                        </h3>

                        <h3>Predictable Performance: <p> Provides consistent and predictable performance regardless of
                                the dataset size. </p>
                        </h3>


                        <h2>Disadvantages of Using Binary Search</h2>
                        <h3>Requires Sorted Data: <p>The array must be sorted prior to performing the binary search.</p>
                        </h3>
                        <h3>Static Data:<p>Inefficient for datasets that change frequently due to the need for
                                re-sorting.</p>
                        </h3>

                        <h3>Index-Based:<p>Only applicable to data structures that allow random access, such as arrays.
                            </p>
                        </h3>


                        <h2>Real-World Examples of Binary Search</h2>
                        <h3>Looking Up Words: <p>Efficiently searching for words in a dictionary.</p>
                        </h3>
                        <h3>Library Catalogs: <p>Finding books in a sorted library catalog.</p>
                        </h3>
                        <h3>Online Shopping: <p>Searching for products in a sorted list of items. </p>
                        </h3>

                        <h3>Version Control: <p>Finding changes in a sorted list of versions in version control systems.
                            </p>
                        </h3>

                        <h3>Stock Prices:<p>Analyzing historical stock prices for a particular date.</p>
                        </h3>


                        <h2>Why is the Time Complexity of Binary Search O(log n)?</h2>
                       <p id="p1">Binary Search works by repeatedly dividing the search interval in half. In each step, the size of the interval is halved, leading to a logarithmic reduction in the number of elements to be checked. Therefore, the time complexity is O(log n), where n is the number of elements in the array. The base of the logarithm is 2, but in Big-O notation, the base is not specified because it only affects the constant factor, not the overall complexity.</p>
                       

                   

 </div>
  </section>   

        </div> <!-- container -->
    </main><!-- Abhishek  -->
</body>

</html>




<script>

    let formsubmit = document.querySelector(".form").addEventListener("submit", datafn)
    let arrayboxex = document.querySelector("#list");
    let visualizer = document.querySelector("#visualizer");
    let ans = document.querySelector("#text");

    function datafn() {
        event.preventDefault();

        arrayboxex.innerHTML = ""
        let arr = [];
        let userArray = document.querySelector("#s1_input1").value;
        let target = document.querySelector("#s1_input2").value;
        target = Number(target);
        arr.push(userArray);
        arr = arr[0].split(",").map(Number);
        arr.sort((a, b) => a - b);
        n = arr.length;
        boxexfn(arr, n);
        binarysearch(arr, n, target);
    }

    //====================Boxex===========================
    let boxexfn = (arr, n) => {
        arr.map(ele => {
            let box = document.createElement("li")
            box.className = "box";
            box.innerText = ele;
            arrayboxex.append(box)
        })
        visualizer.append(arrayboxex)
    }


    // ===============Two Pointerfn==================
    let timeout = 1500; 

function binarysearch(arr, n, target) {
    let low = 0;
    let high = n - 1;
    
    function updateVisualizer(mid, delay) {
        setTimeout(() => {
            arrayboxex.querySelectorAll('.box').forEach(box => box.classList.remove('highlight-low', 'highlight-high', 'highlight-mid'));
            
            if (low < arr.length) arrayboxex.querySelectorAll('.box')[low]?.classList.add('highlight-low');
            if (high < arr.length) arrayboxex.querySelectorAll('.box')[high]?.classList.add('highlight-high');
            if (mid < arr.length) arrayboxex.querySelectorAll('.box')[mid]?.classList.add('highlight-mid');
            
            ans.innerText = `Low: ${low}, High: ${high}, Mid: ${mid}, Mid Value: ${arr[mid]}`;
        }, delay);
    }

    function step() {
        if (low > high) {
            return setTimeout(() => {
                ans.innerText = `Element Not Present in Array.`;
            }, timeout);
        }

        const mid = Math.floor((low + high) / 2);
        updateVisualizer(mid, timeout);

        setTimeout(() => {
            if (arr[mid] === target) {
                ans.innerText = `Element Found At Index : ${mid}`;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
            step(); 
        }, timeout);
    }

    step(); 
}


// ===============Reset==================
let resetfn = ()=>{
        arr = []
        
        window.location.reload();
     }
     reset.addEventListener("click", resetfn)

</script>